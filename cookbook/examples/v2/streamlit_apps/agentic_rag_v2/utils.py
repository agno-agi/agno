from typing import Any, Dict, List, Optional

import streamlit as st
from agentic_rag import get_agentic_rag_agent
from agno.agent import Agent
from agno.models.response import ToolExecution
from agno.utils.log import logger


def add_message(
    role: str, content: str, tool_calls: Optional[List[Dict[str, Any]]] = None
) -> None:
    """Safely add a message to the session state"""
    if "messages" not in st.session_state or not isinstance(
        st.session_state["messages"], list
    ):
        st.session_state["messages"] = []
    st.session_state["messages"].append(
        {"role": role, "content": content, "tool_calls": tool_calls}
    )


def export_chat_history():
    """Export chat history as markdown - improved professional format"""
    if "messages" not in st.session_state or not st.session_state["messages"]:
        return "# Chat History\n\n*No messages to export*"

    # Get session information from agent (more reliable than session state)
    agent = st.session_state.get("agentic_rag_agent")

    # Get the actual session ID - prioritize agent's session_id over session state
    session_id = None
    if agent and hasattr(agent, "session_id") and agent.session_id:
        session_id = agent.session_id
    else:
        session_id = st.session_state.get("agentic_rag_agent_session_id")

    # Determine if this is still a "new chat" or has an actual session
    is_new_chat = not session_id or session_id == "New Chat"

    # Find the first user message to use as title
    title = "Chat History"  # Default fallback
    for msg in st.session_state["messages"]:
        if msg.get("role") == "user":
            user_content = msg.get("content", "").strip()
            if user_content:
                title = user_content

    # Create header with meaningful title
    chat_text = f"# {title}\n\n"

    # Add session metadata in a clean format
    from datetime import datetime

    export_time = datetime.now().strftime("%B %d, %Y at %I:%M %p")

    chat_text += f"**Exported:** {export_time}\n"

    # Show session info based on actual state
    if not is_new_chat:
        # Check if it's a named session (has custom name) vs auto-generated UUID
        session_name = None
        if agent and hasattr(agent, "session_name") and agent.session_name:
            session_name = agent.session_name

        if session_name:
            # Show custom session name
            chat_text += f"**Session:** {session_name}\n"
        elif not _is_uuid_like(session_id):
            # Show session ID only if it's not a long UUID
            chat_text += f"**Session:** {session_id}\n"
        # For UUIDs, don't show the session ID as it's not user-friendly

    # Count meaningful messages (exclude empty/None responses)
    meaningful_messages = [
        msg
        for msg in st.session_state["messages"]
        if msg.get("content")
        and str(msg.get("content")).strip()
        and str(msg.get("content")).strip().lower() != "none"
    ]

    chat_text += f"**Messages:** {len(meaningful_messages)}\n\n"
    chat_text += "---\n\n"

    # Export messages with improved formatting
    for i, msg in enumerate(meaningful_messages, 1):
        role = msg.get("role", "unknown")
        content = str(msg.get("content", "")).strip()

        # Skip empty or "None" content
        if not content or content.lower() == "none":
            continue

        # Format role with better styling
        if role == "user":
            role_display = "## 🙋 User Query"
        elif role == "assistant":
            role_display = "## 🤖 Assistant Response"
        else:
            role_display = f"## {role.capitalize()}"

        chat_text += f"{role_display}\n\n"
        chat_text += f"{content}\n\n"

        # Add separator between exchanges (not after last message)
        if i < len(meaningful_messages):
            chat_text += "---\n\n"

    # Footer
    chat_text += "\n*Generated by Agentic RAG*"
    return chat_text


def _is_uuid_like(text: str) -> bool:
    """Check if text looks like a UUID (contains hyphens and is long)"""
    return len(text) > 20 and "-" in text


def display_tool_calls(tool_calls_container, tools: List[ToolExecution]):
    """Display tool calls in a streamlit container with expandable sections."""
    if not tools:
        return

    with tool_calls_container.container():
        for tool_call in tools:
            # Get basic info from tool call
            if hasattr(tool_call, "tool_name"):
                # ToolExecution object
                tool_name = tool_call.tool_name or "Unknown Tool"
                tool_args = tool_call.tool_args or {}
                content = tool_call.result or ""
                metrics = tool_call.metrics or {}
            else:
                # Dictionary format
                tool_name = (
                    tool_call.get("tool_name")
                    or tool_call.get("name")
                    or "Unknown Tool"
                )
                tool_args = tool_call.get("tool_args") or tool_call.get("args") or {}
                content = tool_call.get("result") or tool_call.get("content") or ""
                metrics = tool_call.get("metrics") or {}

            # Simple title
            title = f"🛠️ {tool_name.replace('_', ' ')}"

            with st.expander(title, expanded=False):
                if tool_args:
                    st.markdown("**Arguments:**")
                    st.json(tool_args)

                if content:
                    st.markdown("**Results:**")
                    if isinstance(content, (dict, list)):
                        st.json(content)
                    else:
                        st.markdown(content)

                if metrics:
                    st.markdown("**Metrics:**")
                    st.json(metrics if isinstance(metrics, dict) else metrics.to_dict())


def rename_session_widget(agent: Agent) -> None:
    """Rename the current session of the agent and save to storage"""

    # Only show rename widget if there's an active session
    if not agent.session_id:
        return

    container = st.sidebar.container()

    # Initialize session_edit_mode if needed
    if "session_edit_mode" not in st.session_state:
        st.session_state.session_edit_mode = False

    # Get current session name, default to session_id if no name is set
    current_name = agent.session_name or agent.session_id

    with container:
        if not st.session_state.session_edit_mode:
            col1, col2 = st.columns([3, 1])
            with col1:
                st.write(f"**Session:** {current_name}")
            with col2:
                if st.button("✎", help="Rename session", key="rename_button"):
                    st.session_state.session_edit_mode = True
                    st.rerun()
        else:
            st.write("**Rename Session:**")

            # Use current session name or session_id as default
            new_session_name = st.text_input(
                "Enter new name:",
                value=current_name,
                key="session_name_input",
                placeholder="Enter session name...",
            )

            col1, col2 = st.columns([1, 1])
            with col1:
                if st.button("💾 Save", type="primary", use_container_width=True):
                    if new_session_name and new_session_name.strip():
                        try:
                            # Use the agent's built-in rename_session method
                            agent.rename_session(new_session_name.strip())
                            logger.debug(
                                f"Renamed session to: {new_session_name.strip()}"
                            )
                            st.session_state.session_edit_mode = False
                            st.sidebar.success("Session renamed!")
                            st.rerun()
                        except Exception as e:
                            logger.error(f"Error renaming session: {e}")
                            st.sidebar.error(f"Failed to rename session: {str(e)}")
                    else:
                        st.sidebar.error("Please enter a valid session name")

            with col2:
                if st.button("❌ Cancel", use_container_width=True):
                    st.session_state.session_edit_mode = False
                    st.rerun()


def knowledge_base_info_widget(agent: Agent) -> None:
    """Display knowledge base information in the sidebar"""

    if (
        agent.knowledge
        and hasattr(agent.knowledge, "vector_db")
        and agent.knowledge.vector_db
    ):
        try:
            # Simply use the get_count() method available on vector databases
            doc_count = agent.knowledge.vector_db.get_count()

            st.sidebar.markdown("### 📚 Knowledge Base")
            st.sidebar.metric(
                label="Documents Loaded",
                value=doc_count,
                help="Number of documents in the knowledge base",
            )

            if doc_count == 0:
                st.sidebar.info(
                    "💡 Upload documents using the sidebar to populate the knowledge base"
                )

        except Exception as e:
            logger.error(f"Error getting knowledge base info: {e}")
            st.sidebar.markdown("### 📚 Knowledge Base")
            st.sidebar.warning("Could not retrieve knowledge base information")
    else:
        st.sidebar.markdown("### 📚 Knowledge Base")
        st.sidebar.info("No knowledge base configured")


def session_selector_widget(agent: Agent, model_id: str) -> None:
    """Display a session selector in the sidebar"""

    # Check if agent has memory with db (v2 pattern)
    if agent.memory and agent.memory.db:
        try:
            # Get sessions from the database using v2 pattern
            from agno.db.base import SessionType

            agent_sessions = agent.memory.db.get_sessions(
                session_type=SessionType.AGENT,
                # Don't filter by component_id to get all agent sessions (like v1)
                deserialize=True,
                sort_by="created_at",
                sort_order="desc",
            )
            logger.debug(f"Found {len(agent_sessions)} agent sessions in database")

            # Also try without session_type filter as backup
            if not agent_sessions:
                logger.debug("No agent sessions found, trying all sessions...")
                all_sessions = agent.memory.db.get_sessions(
                    deserialize=True, sort_by="created_at", sort_order="desc"
                )
                logger.debug(f"Found {len(all_sessions)} total sessions in database")

                # Filter for agent sessions manually if needed
                agent_sessions = [
                    s
                    for s in all_sessions
                    if hasattr(s, "session_type") and s.session_type == "agent"
                ]
                logger.debug(f"Filtered to {len(agent_sessions)} agent sessions")

        except Exception as e:
            logger.error(f"Error fetching sessions: {e}")
            st.sidebar.error("Could not load sessions from database")
            return

        if agent_sessions:
            logger.debug(f"Found {len(agent_sessions)} agent sessions")

            session_dict = {}
            session_options = []

            for session in agent_sessions:
                if hasattr(session, "session_id") and session.session_id:
                    session_id = session.session_id
                    try:
                        # Get session name from session data, fallback to session_id
                        session_name = None
                        if hasattr(session, "session_data") and session.session_data:
                            session_name = session.session_data.get("session_name")

                        # Use session name if available, otherwise use session_id
                        name_to_display = session_name if session_name else session_id

                        # Format session display name with name and timestamp
                        created_at = getattr(session, "created_at", None)
                        if created_at:
                            if hasattr(created_at, "strftime"):
                                time_str = created_at.strftime("%m/%d %H:%M")
                            else:
                                time_str = str(created_at)[:16]
                            display_name = f"{name_to_display} ({time_str})"
                        else:
                            display_name = name_to_display

                        session_options.append(display_name)
                        session_dict[display_name] = session_id
                        logger.debug(
                            f"Added session: {session_id} with name: {name_to_display}"
                        )
                    except Exception as e:
                        logger.debug(f"Error formatting session {session_id}: {e}")
                        continue

            # Handle current session selection
            current_session_id = st.session_state.get("agentic_rag_agent_session_id")
            current_selection = None

            # Find current session in options if it exists
            if current_session_id:
                for display_name, session_id in session_dict.items():
                    if session_id == current_session_id:
                        current_selection = display_name
                        break

            if session_options:
                if not current_session_id:
                    # In new chat mode - add "New Chat" option at the top
                    display_options = ["🆕 New Chat"] + session_options
                    selected_index = 0  # Select "New Chat" by default
                else:
                    # In existing session mode - just show sessions
                    display_options = session_options
                    selected_index = (
                        session_options.index(current_selection)
                        if current_selection and current_selection in session_options
                        else 0
                    )

                # Session dropdown
                selected_option = st.sidebar.selectbox(
                    "💬 Chat Sessions",
                    options=display_options,
                    index=selected_index,
                    help="Select a session to continue a previous conversation or start new chat",
                )

                # Handle selection
                if selected_option == "🆕 New Chat":
                    # User wants to stay in new chat mode - do nothing
                    pass
                else:
                    # User selected an existing session
                    selected_session_id = session_dict.get(selected_option)
                    if (
                        selected_session_id
                        and selected_session_id != current_session_id
                    ):
                        logger.debug(f"Switching to session: {selected_session_id}")
                        load_session_messages(selected_session_id, model_id)
                        st.rerun()
            else:
                # No sessions found - show appropriate message
                current_session_id = st.session_state.get(
                    "agentic_rag_agent_session_id"
                )
                if not current_session_id:
                    st.sidebar.info("🆕 New Chat - Start your conversation!")
                else:
                    st.sidebar.info(
                        "💡 No previous sessions found. Click 'New Chat' to start."
                    )
    else:
        st.sidebar.info("💡 Memory not configured. Sessions will not be saved.")


def load_session_messages(session_id: str, model_id: str) -> None:
    """Load messages for a specific session"""
    try:
        new_agent = get_agentic_rag_agent(
            model_id=model_id,
            session_id=session_id,
        )

        st.session_state["agentic_rag_agent"] = new_agent
        st.session_state["agentic_rag_agent_session_id"] = session_id

        st.session_state["messages"] = []

        try:
            chat_history = new_agent.get_messages_for_session(session_id)

            if chat_history:
                logger.debug(
                    f"Loading {len(chat_history)} messages from session history"
                )
                for message in chat_history:
                    if message.role == "user":
                        add_message("user", str(message.content))
                    elif message.role == "assistant":
                        tool_calls = (
                            getattr(message, "tool_calls", None)
                            if hasattr(message, "tool_calls")
                            else None
                        )
                        add_message("assistant", str(message.content), tool_calls)
            else:
                logger.debug("No chat history found for this session")
        except Exception as e:
            logger.warning(f"Could not load chat history: {e}")

    except Exception as e:
        logger.error(f"Error switching sessions: {str(e)}")
        st.sidebar.error(f"Error loading session: {str(e)}")


def about_widget() -> None:
    """Display an about section in the sidebar"""
    st.sidebar.markdown("---")
    st.sidebar.markdown("### ℹ️ About")
    st.sidebar.markdown("""
    This Agentic RAG Assistant helps you analyze documents and web content using natural language queries.

    Built with:
    - 🚀 Agno
    - 💫 Streamlit
    """)


CUSTOM_CSS = """
    <style>
    /* Main Styles */
   .main-title {
        text-align: center;
        background: linear-gradient(45deg, #FF4B2B, #FF416C);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-size: 3em;
        font-weight: bold;
        padding: 1em 0;
    }
    .subtitle {
        text-align: center;
        color: #666;
        margin-bottom: 2em;
    }
    .stButton button {
        width: 100%;
        border-radius: 20px;
        margin: 0.2em 0;
        transition: all 0.3s ease;
    }
    .stButton button:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    .chat-container {
        border-radius: 15px;
        padding: 1em;
        margin: 1em 0;
        background-color: #f5f5f5;
    }
    .tool-result {
        background-color: #f8f9fa;
        border-radius: 10px;
        padding: 1em;
        margin: 1em 0;
        border-left: 4px solid #3B82F6;
    }
    .status-message {
        padding: 1em;
        border-radius: 10px;
        margin: 1em 0;
    }
    .success-message {
        background-color: #d4edda;
        color: #155724;
    }
    .error-message {
        background-color: #f8d7da;
        color: #721c24;
    }
    /* Dark mode adjustments */
    @media (prefers-color-scheme: dark) {
        .chat-container {
            background-color: #2b2b2b;
        }
        .tool-result {
            background-color: #1e1e1e;
        }
    }
    </style>
"""
