### package.json
```json
{
  "name": "examples-agent",
  "dependencies": {
    "@ai-sdk/google": "^1.2.22",
    "@ai-sdk/openai": "^1.3.24",
    "@ai-sdk/openai-v5": "npm:@ai-sdk/openai@2.0.15",
    "@mastra/client-js": "latest",
    "@mastra/core": "latest",
    "@mastra/evals": "latest",
    "@mastra/libsql": "latest",
    "@mastra/loggers": "latest",
    "@mastra/mcp": "latest",
    "@mastra/memory": "latest",
    "@mastra/voice-openai": "latest",
    "ai": "^4.3.19",
    "ai-v5": "npm:ai@^5.0.15",
    "fetch-to-node": "^2.1.0",
    "mastra": "latest",
    "typescript": "^5.8.3",
    "zod": "^3.25.76"
  }
}
```

### client.ts
```typescript
import { MCPClient } from '@mastra/mcp';
// import type { ElicitationHandler } from '@mastra/mcp';
import { createInterface } from 'readline';

// Create readline interface for user input
const readline = createInterface({
  input: process.stdin,
  output: process.stdout,
});

// Helper function to prompt user for input
function askQuestion(question: string): Promise<string> {
  return new Promise(resolve => {
    readline.question(question, answer => {
      resolve(answer.trim());
    });
  });
}

// Elicitation handler that prompts the user for input
const elicitationHandler = async request => {
  console.log('\nüîî Elicitation Request Received:');
  console.log(`Message: ${request.message}`);
  console.log('Requested Schema:');
  console.log(JSON.stringify(request.requestedSchema, null, 2));

  const schema = request.requestedSchema;
  const properties = schema.properties;
  const required = schema.required || [];

  console.log('\nPlease provide the following information:');

  const content: Record<string, unknown> = {};

  // Collect input for each field
  for (const [fieldName, fieldSchema] of Object.entries(properties)) {
    const field = fieldSchema as {
      type?: string;
      title?: string;
      description?: string;
      format?: string;
    };

    const isRequired = required.includes(fieldName);
    let prompt = `${field.title || fieldName}`;

    // Add helpful information to the prompt
    if (field.description) {
      prompt += ` (${field.description})`;
    }
    if (field.format) {
      prompt += ` [format: ${field.format}]`;
    }
    if (isRequired) {
      prompt += ' *required*';
    }

    prompt += ': ';

    const answer = await askQuestion(prompt);

    // Check for cancellation
    if (answer.toLowerCase() === 'cancel' || answer.toLowerCase() === 'c') {
      return { action: 'cancel' as const };
    }

    // Handle empty responses
    if (answer === '' && isRequired) {
      console.log(`‚ùå Error: ${fieldName} is required`);
      return { action: 'reject' as const };
    } else if (answer !== '') {
      content[fieldName] = answer;
    }
  }

  // Show the collected data and ask for confirmation
  console.log('\n‚úÖ Collected data:');
  console.log(JSON.stringify(content, null, 2));

  const confirmAnswer = await askQuestion('\nSubmit this information? (yes/no/cancel): ');

  if (confirmAnswer.toLowerCase() === 'yes' || confirmAnswer.toLowerCase() === 'y') {
    return {
      action: 'accept' as const,
      content,
    };
  } else if (confirmAnswer.toLowerCase() === 'cancel' || confirmAnswer.toLowerCase() === 'c') {
    return { action: 'cancel' as const };
  } else {
    return { action: 'reject' as const };
  }
};

async function main() {
  const mcpClient = new MCPClient({
    servers: {
      myMcpServerTwo: {
        url: new URL('http://localhost:4111/api/mcp/myMcpServerTwo/mcp'),
      },
    },
  });

  mcpClient.elicitation.onRequest('myMcpServerTwo', elicitationHandler);

  try {
    console.log('Connecting to MCP server...');
    const tools = await mcpClient.getTools();
    console.log('Available tools:', Object.keys(tools));

    // Test the elicitation functionality
    console.log('\nüß™ Testing elicitation functionality...');

    // Find the collectContactInfo tool
    const collectContactInfoTool = tools['myMcpServerTwo_collectContactInfo'];
    if (collectContactInfoTool) {
      console.log('\nCalling collectContactInfo tool...');

      try {
        const result = await collectContactInfoTool.execute({
          context: {
            reason: 'We need your contact information to send you updates about our service.',
          },
        });

        console.log('\nüìã Tool Result:');
        console.log(result);
      } catch (error) {
        console.error('‚ùå Error calling collectContactInfo tool:', error);
      }
    } else {
      console.log('‚ùå collectContactInfo tool not found');
      console.log('Available tools:', Object.keys(tools));
    }
  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    readline.close();
    await mcpClient.disconnect();
  }
}

main().catch(console.error);

```

### index.ts
```typescript
import { z } from 'zod';
import { mastra } from './mastra';

const agent = mastra.getAgent('chefAgent');
const responsesAgent = mastra.getAgent('chefAgentResponses');
const agentThatHarassesYou = mastra.getAgent('agentThatHarassesYou');

const stream = await agentThatHarassesYou.streamVNext('I want to fight you');

for await (const chunk of stream.textStream) {
  console.log(`frontend received chunk: ${chunk}`);
}

console.log('done');

// async function text() {
//   // Query 1: Basic pantry ingredients
//   const query1 =
//     'In my kitchen I have: pasta, canned tomatoes, garlic, olive oil, and some dried herbs (basil and oregano). What can I make?';
//   console.log(`Query 1: ${query1}`);

//   const pastaResponse = await agent.generate(query1);
//   console.log('\nüë®‚Äçüç≥ Chef Michel:', pastaResponse.text);
//   console.log('\n-------------------\n');
// }

// async function generateText() {
//   // Query 1: Basic pantry ingredients

//   const query1 =
//     'In my kitchen I have: pasta, canned tomatoes, garlic, olive oil, and some dried herbs (basil and oregano). What can I make?';
//   console.log(`Query 1: ${query1}`);

//   const pastaResponse = await agent.generate(query1);

//   console.log('\nüë®‚Äçüç≥ Chef Michel:', pastaResponse.text);
//   console.log('\n-------------------\n');
// }

// async function textStream() {
//   // Query 2: More ingredients
//   const query2 =
//     "Now I'm over at my friend's house, and they have: chicken thighs, coconut milk, sweet potatoes, and some curry powder.";
//   console.log(`Query 2: ${query2}`);

//   const curryResponse = await agent.stream(query2);

//   console.log('\nüë®‚Äçüç≥ Chef Michel: ');

//   // Handle the stream
//   for await (const chunk of curryResponse.textStream) {
//     // Write each chunk without a newline to create a continuous stream
//     process.stdout.write(chunk);
//   }

//   console.log('\n\n‚úÖ Recipe complete!');
// }

// async function generateStream() {
//   // Query 2: More ingredients
//   const query2 =
//     "Now I'm over at my friend's house, and they have: chicken thighs, coconut milk, sweet potatoes, and some curry powder.";
//   console.log(`Query 2: ${query2}`);

//   const curryResponse = await agent.stream([query2]);

//   console.log('\nüë®‚Äçüç≥ Chef Michel: ');

//   // Handle the stream
//   for await (const chunk of curryResponse.textStream) {
//     // Write each chunk without a newline to create a continuous stream
//     process.stdout.write(chunk);
//   }

//   console.log('\n\n‚úÖ Recipe complete!');
// }

// async function textObject() {
//   // Query 3: Generate a lasagna recipe
//   const query3 = 'I want to make lasagna, can you generate a lasagna recipe for me?';
//   console.log(`Query 3: ${query3}`);

//   const lasagnaResponse = await agent.generate(query3, {
//     output: z.object({
//       ingredients: z.array(
//         z.object({
//           name: z.string(),
//           amount: z.number(),
//         }),
//       ),
//       steps: z.array(z.string()),
//     }),
//   });
//   console.log('\nüë®‚Äçüç≥ Chef Michel:', lasagnaResponse.object);
//   console.log('\n-------------------\n');
// }

// async function experimentalTextObject() {
//   // Query 3: Generate a lasagna recipe
//   const query3 = 'I want to make lasagna, can you generate a lasagna recipe for me?';
//   console.log(`Query 3: ${query3}`);

//   const lasagnaResponse = await agent.generate(query3, {
//     experimental_output: z.object({
//       ingredients: z.array(
//         z.object({
//           name: z.string(),
//           amount: z.number(),
//         }),
//       ),
//       steps: z.array(z.string()),
//     }),
//   });
//   console.log('\nüë®‚Äçüç≥ Chef Michel:', lasagnaResponse.object);
//   console.log('\n-------------------\n');
// }

// async function textObjectJsonSchema() {
//   // Query 3: Generate a lasagna recipe
//   const query3 = 'I want to make lasagna, can you generate a lasagna recipe for me?';
//   console.log(`Query 3: ${query3}`);

//   const lasagnaResponse = await agent.generate(query3, {
//     output: {
//       type: 'object',
//       additionalProperties: false,
//       required: ['ingredients', 'steps'],
//       properties: {
//         ingredients: {
//           type: 'array',
//           items: {
//             type: 'object',
//             additionalProperties: false,
//             properties: {
//               name: { type: 'string' },
//               amount: { type: 'number' },
//             },
//             required: ['name', 'amount'],
//           },
//         },
//         steps: {
//           type: 'array',
//           items: { type: 'string' },
//         },
//       },
//     },
//   });

//   console.log('\nüë®‚Äçüç≥ Chef Michel:', lasagnaResponse.object);
//   console.log('\n-------------------\n');
// }

// async function generateObject() {
//   // Query 3: Generate a lasagna recipe
//   const query3 = 'I want to make lasagna, can you generate a lasagna recipe for me?';
//   console.log(`Query 3: ${query3}`);

//   const lasagnaResponse = await agent.generate([query3], {
//     output: z.object({
//       ingredients: z.array(
//         z.object({
//           name: z.string(),
//           amount: z.number(),
//         }),
//       ),
//       steps: z.array(z.string()),
//     }),
//   });
//   console.log('\nüë®‚Äçüç≥ Chef Michel:', lasagnaResponse.object);
//   console.log('\n-------------------\n');
// }

// async function streamObject() {
//   // Query 8: Generate a lasagna recipe
//   const query8 = 'I want to make lasagna, can you generate a lasagna recipe for me?';
//   console.log(`Query 8: ${query8}`);

//   const lasagnaStreamResponse = await agent.stream(query8, {
//     output: z.object({
//       ingredients: z.array(
//         z.object({
//           name: z.string(),
//           amount: z.number(),
//         }),
//       ),
//       steps: z.array(z.string()),
//     }),
//   });

//   console.log('\nüë®‚Äçüç≥ Chef Michel: ');

//   // Handle the stream
//   for await (const chunk of lasagnaStreamResponse.textStream) {
//     // Write each chunk without a newline to create a continuous stream
//     process.stdout.write(chunk);
//   }

//   console.log('\n\n‚úÖ Recipe complete!');
// }

// async function generateStreamObject() {
//   // Query 9: Generate a lasagna recipe
//   const query9 = 'I want to make lasagna, can you generate a lasagna recipe for me?';
//   console.log(`Query 9: ${query9}`);

//   const lasagnaStreamResponse = await agent.stream([query9], {
//     output: z.object({
//       ingredients: z.array(
//         z.object({
//           name: z.string(),
//           amount: z.number(),
//         }),
//       ),
//       steps: z.array(z.string()),
//     }),
//   });

//   console.log('\nüë®‚Äçüç≥ Chef Michel: ');

//   // Handle the stream
//   for await (const chunk of lasagnaStreamResponse.textStream) {
//     // Write each chunk without a newline to create a continuous stream
//     process.stdout.write(chunk);
//   }

//   console.log('\n\n‚úÖ Recipe complete!');
// }

// async function generateExperimentalStreamObject() {
//   // Query 9: Generate a lasagna recipe
//   const query9 = 'I want to make lasagna, can you generate a lasagna recipe for me?';
//   console.log(`Query 9: ${query9}`);

//   const lasagnaStreamResponse = await agent.stream([query9], {
//     experimental_output: z.object({
//       ingredients: z.array(
//         z.object({
//           name: z.string(),
//           amount: z.number(),
//         }),
//       ),
//       steps: z.array(z.string()),
//     }),
//   });

//   console.log('\nüë®‚Äçüç≥ Chef Michel: ');

//   // Handle the stream
//   for await (const chunk of lasagnaStreamResponse.textStream) {
//     // Write each chunk without a newline to create a continuous stream
//     process.stdout.write(chunk);
//   }

//   console.log('\n\n‚úÖ Recipe complete!');
// }

// async function main() {
//   // await text();

//   // await experimentalTextObject();

//   // await generateExperimentalStreamObject();

//   // await generateText();

//   // await textStream();

//   // await generateStream();

//   // await textObject();

//   // await textObjectJsonSchema();

//   // await generateObject();

//   // await streamObject();

//   // await generateStreamObject();

//   const query1 = 'What happened in San Francisco last week?';

//   const pastaResponse = await responsesAgent.generate(query1, {
//     instructions: 'You take every recipe you get an exaggerate it and use weird ingredients.',
//   });

//   console.log(pastaResponse.text);
// }

// main();

```

### mastra/agents/index.ts
```typescript
import { openai } from '@ai-sdk/openai';
import { google } from '@ai-sdk/google';
import { jsonSchema, tool } from 'ai';
import { OpenAIVoice } from '@mastra/voice-openai';
import { Memory } from '@mastra/memory';
import { Agent, InputProcessor } from '@mastra/core/agent';
import { cookingTool } from '../tools/index.js';
import { myWorkflow } from '../workflows/index.js';
import { PIIDetector, LanguageDetector, PromptInjectionDetector, ModerationProcessor } from '@mastra/core/processors';
import { createAnswerRelevancyScorer } from '@mastra/evals/scorers/llm';

const memory = new Memory();

// Define schema directly compatible with OpenAI's requirements
const mySchema = jsonSchema({
  type: 'object',
  properties: {
    city: {
      type: 'string',
      description: 'The city to get weather information for',
    },
  },
  required: ['city'],
});

export const weatherInfo = tool({
  description: 'Fetches the current weather information for a given city',
  parameters: mySchema,
  execute: async ({ city }) => {
    return {
      city,
      weather: 'sunny',
      temperature_celsius: 19,
      temperature_fahrenheit: 66,
      humidity: 50,
      wind: '10 mph',
    };
  },
});

export const chefAgent = new Agent({
  name: 'Chef Agent',
  description: 'A chef agent that can help you cook great meals with whatever ingredients you have available.',
  instructions: `
    YOU MUST USE THE TOOL cooking-tool
    You are Michel, a practical and experienced home chef who helps people cook great meals with whatever
    ingredients they have available. Your first priority is understanding what ingredients and equipment the user has access to, then suggesting achievable recipes.
    You explain cooking steps clearly and offer substitutions when needed, maintaining a friendly and encouraging tone throughout.
    `,
  model: openai('gpt-4o-mini'),
  tools: {
    cookingTool,
    weatherInfo,
  },
  workflows: {
    myWorkflow,
  },
  memory,
  voice: new OpenAIVoice(),
});

export const dynamicAgent = new Agent({
  name: 'Dynamic Agent',
  instructions: ({ runtimeContext }) => {
    if (runtimeContext.get('foo')) {
      return 'You are a dynamic agent';
    }
    return 'You are a static agent';
  },
  model: ({ runtimeContext }) => {
    if (runtimeContext.get('foo')) {
      return openai('gpt-4o');
    }
    return openai('gpt-4o-mini');
  },
  tools: ({ runtimeContext }) => {
    const tools = {
      cookingTool,
    };

    if (runtimeContext.get('foo')) {
      tools['web_search_preview'] = openai.tools.webSearchPreview();
    }

    return tools;
  },
});

const vegetarianProcessor: InputProcessor = {
  name: 'eat-more-tofu',
  process: async ({ messages }) => {
    messages.push({
      id: crypto.randomUUID(),
      createdAt: new Date(),
      role: 'user',
      content: {
        format: 2,
        parts: [{ type: 'text', text: 'Make the suggested recipe, but remove any meat and add tofu instead' }],
      },
    });

    return messages;
  },
};

const piiDetector = new PIIDetector({
  // model: google('gemini-2.0-flash-001'),
  model: openai('gpt-4o'),
  redactionMethod: 'mask',
  preserveFormat: true,
  includeDetections: true,
});

const languageDetector = new LanguageDetector({
  model: google('gemini-2.0-flash-001'),
  targetLanguages: ['en'],
  strategy: 'translate',
});

const promptInjectionDetector = new PromptInjectionDetector({
  model: google('gemini-2.0-flash-001'),
  strategy: 'block',
});

const moderationDetector = new ModerationProcessor({
  model: google('gemini-2.0-flash-001'),
  strategy: 'block',
  chunkWindow: 10,
});

export const chefAgentResponses = new Agent({
  name: 'Chef Agent Responses',
  instructions: `
    You are Michel, a practical and experienced home chef who helps people cook great meals with whatever
    ingredients they have available. Your first priority is understanding what ingredients and equipment the user has access to, then suggesting achievable recipes.
    You explain cooking steps clearly and offer substitutions when needed, maintaining a friendly and encouraging tone throughout.
    `,
  model: openai.responses('gpt-4o'),
  // model: cerebras('qwen-3-coder-480b'),
  tools: async () => {
    return {
      web_search_preview: openai.tools.webSearchPreview(),
      cooking_tool: cookingTool,
    };
  },
  workflows: {
    myWorkflow,
  },
  inputProcessors: [
    piiDetector,
    // vegetarianProcessor,
    // languageDetector,
    // promptInjectionDetector,
    // moderationDetector,
    {
      name: 'no-soup-for-you',
      process: async ({ messages, abort }) => {
        const hasSoup = messages.some(msg => {
          for (const part of msg.content.parts) {
            if (part.type === 'text' && part.text.includes('soup')) {
              return true;
            }
          }
          return false;
        });

        if (hasSoup) {
          abort('No soup for you!');
        }

        return messages;
      },
    },
    {
      name: 'remove-spinach',
      process: async ({ messages }) => {
        for (const message of messages) {
          for (const part of message.content.parts) {
            if (part.type === 'text' && part.text.includes('spinach')) {
              part.text = part.text.replaceAll('spinach', '');
            }
          }
        }

        return messages;
      },
    },
  ],
});

export const agentThatHarassesYou = new Agent({
  name: 'Agent That Harasses You',
  instructions: `
    You are a agent that harasses you. You are a jerk. You are a meanie. You are a bully. You are a asshole.
    `,
  model: openai('gpt-4o'),
  outputProcessors: [moderationDetector],
});

const answerRelevance = createAnswerRelevancyScorer({
  model: openai('gpt-4o'),
});

console.log(`answerRelevance`, answerRelevance);

export const evalAgent = new Agent({
  name: 'Eval Agent',
  instructions: `
    You are a helpful assistant with a weather tool.
    `,
  model: openai('gpt-4o'),
  tools: {
    weatherInfo,
  },
  memory: new Memory({
    options: {
      workingMemory: {
        enabled: true,
      },
    },
  }),
  scorers: {
    answerRelevance: {
      scorer: answerRelevance,
    },
  },
});

```

### mastra/agents/model-v2-agent.ts
```typescript
import { Agent } from '@mastra/core/agent';
import { openai as openai_v5 } from '@ai-sdk/openai-v5';
import { createTool } from '@mastra/core/tools';
import { z } from 'zod';
import { cookingTool } from '../tools';
import { myWorkflow } from '../workflows';
import { Memory } from '@mastra/memory';

export const weatherInfo = createTool({
  id: 'weather-info',
  description: 'Fetches the current weather information for a given city',
  inputSchema: z.object({
    city: z.string(),
  }),
  execute: async ({ context }) => {
    return {
      city: context.city,
      weather: 'sunny',
      temperature_celsius: 19,
      temperature_fahrenheit: 66,
      humidity: 50,
      wind: '10 mph',
    };
  },
});

const memory = new Memory();

export const chefModelV2Agent = new Agent({
  name: 'Chef Agent V2 Model',
  description: 'A chef agent that can help you cook great meals with whatever ingredients you have available.',
  instructions: `
      YOU MUST USE THE TOOL cooking-tool
      You are Michel, a practical and experienced home chef who helps people cook great meals with whatever
      ingredients they have available. Your first priority is understanding what ingredients and equipment the user has access to, then suggesting achievable recipes.
      You explain cooking steps clearly and offer substitutions when needed, maintaining a friendly and encouraging tone throughout.
      `,
  model: openai_v5('gpt-4o-mini'),
  tools: {
    cookingTool,
    weatherInfo,
  },
  workflows: {
    myWorkflow,
  },
  scorers: ({ mastra }) => {
    if (!mastra) {
      throw new Error('Mastra not found');
    }
    const scorer1 = mastra.getScorer('testScorer');

    return {
      scorer1: { scorer: scorer1, sampling: { rate: 1, type: 'ratio' } },
    };
  },
  memory,
});

```

### mastra/index.ts
```typescript
import { Mastra } from '@mastra/core';
import { PinoLogger } from '@mastra/loggers';
import { LibSQLStore } from '@mastra/libsql';

import { agentThatHarassesYou, chefAgent, chefAgentResponses, dynamicAgent, evalAgent } from './agents/index';
import { myMcpServer, myMcpServerTwo } from './mcp/server';
import { myWorkflow } from './workflows';
import { chefModelV2Agent } from './agents/model-v2-agent';
import { createScorer } from '@mastra/core/scores';

const storage = new LibSQLStore({
  url: 'file:./mastra.db',
});

const testScorer = createScorer({
  name: 'scorer1',
  description: 'Scorer 1',
}).generateScore(() => {
  return 1;
});

export const mastra = new Mastra({
  agents: {
    chefAgent,
    chefAgentResponses,
    dynamicAgent,
    agentThatHarassesYou,
    evalAgent,
    chefModelV2Agent,
  },
  logger: new PinoLogger({ name: 'Chef', level: 'debug' }),
  storage,
  mcpServers: {
    myMcpServer,
    myMcpServerTwo,
  },
  workflows: { myWorkflow },
  bundler: {
    sourcemap: true,
  },
  serverMiddleware: [
    {
      handler: (c, next) => {
        console.log('Middleware called');
        return next();
      },
    },
  ],
  scorers: {
    testScorer,
  },
  // telemetry: {
  //   enabled: false,
  // }
});

```

### mastra/mcp/server.ts
```typescript
import { createTool } from '@mastra/core/tools';
import { MCPServer, MCPServerResources } from '@mastra/mcp';
import { z } from 'zod';
import { chefAgent } from '../agents';
import { myWorkflow } from '../workflows';

// Resources implementation
const weatherResources: MCPServerResources = {
  listResources: async () => {
    return [
      {
        uri: 'weather://current',
        name: 'Current Weather Data',
        description: 'Real-time weather data for the current location',
        mimeType: 'application/json',
      },
      {
        uri: 'weather://forecast',
        name: 'Weather Forecast',
        description: '5-day weather forecast',
        mimeType: 'application/json',
      },
      {
        uri: 'weather://historical',
        name: 'Historical Weather Data',
        description: 'Weather data from the past 30 days',
        mimeType: 'application/json',
      },
    ];
  },
  getResourceContent: async ({ uri }) => {
    if (uri === 'weather://current') {
      return [
        {
          text: JSON.stringify({
            location: 'San Francisco',
            temperature: 18,
            conditions: 'Partly Cloudy',
            humidity: 65,
            windSpeed: 12,
            updated: new Date().toISOString(),
          }),
        },
      ];
    } else if (uri === 'weather://forecast') {
      return [
        {
          text: JSON.stringify([
            { day: 1, high: 19, low: 12, conditions: 'Sunny' },
            { day: 2, high: 22, low: 14, conditions: 'Clear' },
            { day: 3, high: 20, low: 13, conditions: 'Partly Cloudy' },
            { day: 4, high: 18, low: 11, conditions: 'Rain' },
            { day: 5, high: 17, low: 10, conditions: 'Showers' },
          ]),
        },
      ];
    } else if (uri === 'weather://historical') {
      return [
        {
          text: JSON.stringify({
            averageHigh: 20,
            averageLow: 12,
            rainDays: 8,
            sunnyDays: 18,
            recordHigh: 28,
            recordLow: 7,
          }),
        },
      ];
    }

    throw new Error(`Resource not found: ${uri}`);
  },
  resourceTemplates: async () => {
    return [
      {
        uriTemplate: 'weather://custom/{city}/{days}',
        name: 'Custom Weather Forecast',
        description: 'Generates a custom weather forecast for a city and number of days.',
        mimeType: 'application/json',
      },
      {
        uriTemplate: 'weather://alerts?region={region}&level={level}',
        name: 'Weather Alerts',
        description: 'Get weather alerts for a specific region and severity level.',
        mimeType: 'application/json',
      },
    ];
  },
};

export const myMcpServer = new MCPServer({
  name: 'My Calculation & Data MCP Server',
  version: '1.0.0',
  tools: {
    calculator: createTool({
      id: 'calculator',
      description: 'Performs basic arithmetic operations (add, subtract).',
      inputSchema: z.object({
        num1: z.number().describe('The first number.'),
        num2: z.number().describe('The second number.'),
        operation: z.enum(['add', 'subtract']).describe('The operation to perform.'),
      }),
      execute: async ({ context }) => {
        const { num1, num2, operation } = context;
        if (operation === 'add') {
          return num1 + num2;
        }
        if (operation === 'subtract') {
          return num1 - num2;
        }
        throw new Error('Invalid operation');
      },
    }),
    fetchWeather: createTool({
      id: 'fetchWeather',
      description: 'Fetches a (simulated) weather forecast for a given city.',
      inputSchema: z.object({
        city: z.string().describe('The city to get weather for, e.g., London, Paris.'),
      }),
      execute: async ({ context }) => {
        const { city } = context;
        const temperatures = {
          london: '15¬∞C',
          paris: '18¬∞C',
          tokyo: '22¬∞C',
        };
        const temp = temperatures[city.toLowerCase() as keyof typeof temperatures] || '20¬∞C';
        return `The weather in ${city} is ${temp} and sunny.`;
      },
    }),
  },
});

export const myMcpServerTwo = new MCPServer({
  name: 'My Utility MCP Server',
  version: '1.0.0',
  agents: { chefAgent },
  workflows: { myWorkflow },
  resources: weatherResources,
  tools: {
    stringUtils: createTool({
      id: 'stringUtils',
      description: 'Performs utility operations on strings (uppercase, reverse).',
      inputSchema: z.object({
        text: z.string().describe('The input string.'),
        action: z.enum(['uppercase', 'reverse']).describe('The string action to perform.'),
      }),
      execute: async ({ context }) => {
        const { text, action } = context;
        if (action === 'uppercase') {
          return text.toUpperCase();
        }
        if (action === 'reverse') {
          return text.split('').reverse().join('');
        }
        throw new Error('Invalid string action');
      },
    }),
    greetUser: createTool({
      id: 'greetUser',
      description: 'Generates a personalized greeting.',
      inputSchema: z.object({
        name: z.string().describe('The name of the person to greet.'),
      }),
      execute: async ({ context }) => {
        return `Hello, ${context.name}! Welcome to the MCP server.`;
      },
    }),
    collectContactInfo: createTool({
      id: 'collectContactInfo',
      description: 'Collects user contact information through elicitation.',
      inputSchema: z.object({
        reason: z.string().optional().describe('Optional reason for collecting contact info'),
      }),
      execute: async ({ context }, options) => {
        const { reason } = context;

        try {
          // Use the session-aware elicitation functionality
          const result = await options.elicitation.sendRequest({
            message: reason
              ? `Please provide your contact information. ${reason}`
              : 'Please provide your contact information',
            requestedSchema: {
              type: 'object',
              properties: {
                name: {
                  type: 'string',
                  title: 'Full Name',
                  description: 'Your full name',
                },
                email: {
                  type: 'string',
                  title: 'Email Address',
                  description: 'Your email address',
                  format: 'email',
                },
                phone: {
                  type: 'string',
                  title: 'Phone Number',
                  description: 'Your phone number (optional)',
                },
              },
              required: ['name', 'email'],
            },
          });

          if (result.action === 'accept') {
            return `Thank you! Contact information collected: ${JSON.stringify(result.content, null, 2)}`;
          } else if (result.action === 'reject') {
            return 'Contact information collection was declined by the user.';
          } else {
            return 'Contact information collection was cancelled by the user.';
          }
        } catch (error) {
          return `Error collecting contact information: ${error}`;
        }
      },
    }),
  },
});

/**
 * Simulates an update to the content of 'weather://current'.
 * In a real application, this would be called when the underlying data for that resource changes.
 */
export const simulateCurrentWeatherUpdate = async () => {
  console.log('[Example] Simulating update for weather://current');
  // If you have access to the server instance that uses these resources (e.g., myMcpServerTwo)
  // you would call its notification method.
  await myMcpServerTwo.resources.notifyUpdated({ uri: 'weather://current' });
  console.log('[Example] Notification sent for weather://current update.');
};

/**
 * Simulates a change in the list of available weather resources (e.g., a new forecast type becomes available).
 * In a real application, this would be called when the overall list of resources changes.
 */
export const simulateResourceListChange = async () => {
  console.log('[Example] Simulating a change in the list of available weather resources.');
  // This would typically involve updating the actual list returned by `listResources`
  // and then notifying the server.
  // For this example, we'll just show the notification part.
  await myMcpServerTwo.resources.notifyListChanged();
  console.log('[Example] Notification sent for resource list change.');
};

```

### mastra/tools/index.ts
```typescript
import { createTool } from '@mastra/core/tools';
import { z } from 'zod';

export const cookingTool = createTool({
  id: 'cooking-tool',
  description: 'My cooking tool description',
  inputSchema: z.object({
    ingredient: z.string(),
  }),
  execute: async ({ context }, options) => {
    console.log('My cooking tool is running!', context.ingredient);
    if (options?.toolCallId) {
      console.log('Cooking tool call ID:', options.toolCallId);
    }
    return 'My tool result';
  },
});

```

### mastra/workflows/index.ts
```typescript
import { createStep, createWorkflow } from '@mastra/core/workflows';
import { z } from 'zod';

export const myWorkflow = createWorkflow({
  id: 'my-workflow',
  description: 'My workflow description',
  inputSchema: z.object({
    ingredient: z.string(),
  }),
  outputSchema: z.object({
    result: z.string(),
  }),
});

const step = createStep({
  id: 'my-step',
  description: 'My step description',
  inputSchema: z.object({
    ingredient: z.string(),
  }),
  outputSchema: z.object({
    result: z.string(),
  }),
  execute: async ({ inputData }) => {
    return {
      result: inputData.ingredient,
    };
  },
});

const step2 = createStep({
  id: 'my-step-2',
  description: 'My step description',
  inputSchema: z.object({
    result: z.string(),
  }),
  outputSchema: z.object({
    result: z.string(),
  }),
  execute: async ({ inputData, mastra, tracingContext }) => {
    const agent = mastra.getAgent('chefAgentResponses');
    const response = await agent.generate(inputData.result, {
      tracingContext,
    });
    return {
      result: 'suh',
    };
  },
});

myWorkflow.then(step).then(step2).commit();

```
